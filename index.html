<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Toby's Robo-Runner</title>
    <style>
        * {
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            touch-action: none;
        }
        
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            position: fixed;
            width: 100%;
            height: 100%;
            background: linear-gradient(to bottom, #87CEEB, #E0F6FF);
            font-family: -apple-system, Arial, sans-serif;
        }
        
        #gameContainer {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        
        #gameCanvas {
            width: 100%;
            height: 100%;
            display: block;
            background: linear-gradient(to bottom, #87CEEB, #98FB98);
        }
        
        #gameInfo {
            position: absolute;
            top: env(safe-area-inset-top, 20px);
            left: 0;
            right: 0;
            text-align: center;
            font-size: 24px;
            font-weight: bold;
            color: #fff;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            padding: 10px;
            z-index: 10;
        }
        
        #score {
            background: rgba(0,0,0,0.3);
            padding: 5px 15px;
            border-radius: 20px;
            display: inline-block;
        }
        
        #message {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        #tapToJump {
            position: absolute;
            bottom: 10%;
            left: 50%;
            transform: translateX(-50%);
            font-size: 20px;
            color: #fff;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            background: rgba(0,0,0,0.3);
            padding: 10px 20px;
            border-radius: 20px;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 1; }
        }
        
        @media (orientation: landscape) {
            #gameInfo { font-size: 20px; }
            #tapToJump { font-size: 18px; }
        }
        
        /* Modal container styles */
        .modal-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #87CEEB;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            padding: 20px;
            box-sizing: border-box;
        }
        
        .modal-content {
            background: white;
            border-radius: 20px;
            padding: 20px 40px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.2);
            max-width: 90%;
            max-height: 85%;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }
        
        .modal-title {
            color: #4169E1;
            font-size: clamp(28px, 5vw, 48px);
            margin: 0;
            text-align: center;
            font-family: Arial, sans-serif;
        }
        
        .modal-button {
            background: #4169E1;
            color: white;
            font-size: clamp(20px, 3vw, 32px);
            padding: 15px 40px;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            font-family: Arial, sans-serif;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            transform: scale(1);
            transition: transform 0.1s;
        }
        
        .modal-button:hover {
            transform: scale(1.1);
        }
        
        .modal-button:active {
            transform: scale(0.95);
        }
        
        /* Landscape-specific modal layout */
        @media (orientation: landscape) {
            .modal-content {
                flex-direction: column;
                padding: 20px 30px;
            }
            
            .instructions-container {
                display: flex;
                flex-direction: row;
                gap: 30px;
                align-items: flex-start;
                justify-content: center;
                flex-wrap: nowrap;
            }
            
            .instruction-item {
                display: flex;
                flex-direction: column;
                align-items: center;
                gap: 10px;
                font-size: clamp(14px, 2vw, 20px);
                text-align: center;
                flex: 1;
                min-width: 0;
            }
            
            .instruction-item span:first-child {
                font-size: 2.5em;
            }
        }
        
        /* Portrait-specific modal layout */
        @media (orientation: portrait) {
            .instructions-container {
                display: flex;
                flex-direction: column;
                gap: 15px;
            }
            
            .instruction-item {
                display: flex;
                flex-direction: row;
                align-items: center;
                gap: 15px;
                font-size: clamp(18px, 3vw, 24px);
            }
            
            .instruction-item span:first-child {
                font-size: 1.5em;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="gameInfo">
            <div>Score: <span id="score">0</span></div>
        </div>
        <canvas id="gameCanvas"></canvas>
        <div id="tapToJump">Tap to Jump! ü§ñ</div>
        <div id="message"></div>
        <div id="startScreen" class="modal-overlay">
            <div class="modal-content">
                <h1 class="modal-title">Toby's Robo-Runner ü§ñ</h1>
                <div class="instructions-container">
                    <div class="instruction-item">
                        <span style="font-size: 1.5em;">ü§ñ</span>
                        <span>You are a robot!</span>
                    </div>
                    <div class="instruction-item">
                        <span style="font-size: 1.5em;">üëÜ</span>
                        <span>Tap to jump</span>
                    </div>
                    <div class="instruction-item">
                        <span style="font-size: 1.5em;">‚öôÔ∏è</span>
                        <span>Jump over obstacles</span>
                    </div>
                    <div class="instruction-item">
                        <span style="font-size: 1.5em;">üèÉ</span>
                        <span>Get points!</span>
                    </div>
                </div>
                <button id="startButton" class="modal-button">
                    Start Game! üéÆ
                </button>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');
        const messageEl = document.getElementById('message');
        const tapToJumpEl = document.getElementById('tapToJump');
        const startScreenEl = document.getElementById('startScreen');
        const startButtonEl = document.getElementById('startButton');
        
        // Set canvas size to full screen
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            // Scale everything based on canvas size
            return Math.min(canvas.width / 800, canvas.height / 400);
        }
        
        let scale = resizeCanvas();
        window.addEventListener('resize', () => {
            scale = resizeCanvas();
        });

        // Game variables
        let score = 0;
        let gameSpeed = 240; // pixels per second (reduced by 20% for easier gameplay)
        let gameRunning = false;
        let gameStarted = false;
        let canRestart = false;
        let animationId = null;
        let lastTime = 0;

        // Robot class
        class Robot {
            constructor() {
                this.x = 100;
                this.y = 0;
                this.width = 50;
                this.height = 60;
                this.velocityY = 0;
                this.gravity = 0.8;
                this.jumpPower = -18;
                this.grounded = true;
                this.color = '#4169E1';
                this.eyeBlink = 0;
                this.groundY = 0;
                this.legAnimation = 0;
            }

            jump() {
                if (this.grounded) {
                    this.velocityY = this.jumpPower * scale;
                    this.grounded = false;
                }
            }

            update() {
                // Apply gravity
                this.velocityY += this.gravity * scale;
                this.y += this.velocityY;

                // Ground collision
                this.groundY = canvas.height - 120 * scale;
                if (this.y > this.groundY - this.height * scale) {
                    this.y = this.groundY - this.height * scale;
                    this.velocityY = 0;
                    this.grounded = true;
                }

                // Blink animation
                this.eyeBlink = Math.random() > 0.98 ? 10 : Math.max(0, this.eyeBlink - 1);
                
                // Leg animation for running
                if (this.grounded && gameRunning) {
                    this.legAnimation += 0.3;
                }
            }

            draw() {
                const s = scale;
                
                // Add bounce effect when running
                let bounceOffset = 0;
                if (this.grounded && gameRunning) {
                    bounceOffset = Math.sin(this.legAnimation) * 3; // Smooth up/down motion synced with legs
                }
                const yPos = this.y - bounceOffset * s;
                
                // Animated legs (draw from body position to ensure no gap)
                ctx.fillStyle = '#6495ED';
                const legOffset1 = Math.sin(this.legAnimation) * 5;
                const legOffset2 = Math.sin(this.legAnimation + Math.PI) * 5;
                
                if (this.grounded && gameRunning) {
                    // Running animation - legs start from body bottom
                    ctx.fillRect(this.x * s + 10 * s + legOffset1 * s, yPos + this.height * s, 10 * s, 20 * s + bounceOffset * s);
                    ctx.fillRect(this.x * s + 30 * s + legOffset2 * s, yPos + this.height * s, 10 * s, 20 * s + bounceOffset * s);
                } else {
                    // Static legs when jumping or game over
                    ctx.fillRect(this.x * s + 10 * s, this.y + this.height * s, 10 * s, 20 * s);
                    ctx.fillRect(this.x * s + 30 * s, this.y + this.height * s, 10 * s, 20 * s);
                }
                
                // Right arm (behind body)
                ctx.fillStyle = '#6495ED';
                const armOffset = Math.sin(this.legAnimation + Math.PI) * 5; // Offset from legs for natural motion
                
                if (this.grounded && gameRunning) {
                    // Right arm (behind) - vertical orientation, horizontal movement
                    ctx.fillRect(this.x * s + this.width * s - 5 * s - armOffset * s, yPos + 10 * s, 10 * s, 30 * s);
                } else {
                    // Static right arm
                    ctx.fillRect(this.x * s + this.width * s - 5 * s, yPos + 10 * s, 10 * s, 30 * s);
                }
                
                // Body
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x * s, yPos, this.width * s, this.height * s);
                
                // Left arm (in front of body)
                ctx.fillStyle = '#6495ED';
                if (this.grounded && gameRunning) {
                    // Left arm (front) - vertical orientation, horizontal movement
                    ctx.fillRect(this.x * s - 5 * s + armOffset * s, yPos + 10 * s, 10 * s, 30 * s);
                } else {
                    // Static left arm
                    ctx.fillRect(this.x * s - 5 * s, yPos + 10 * s, 10 * s, 30 * s);
                }

                // Head
                ctx.fillStyle = '#6495ED';
                ctx.fillRect(this.x * s + 5 * s, yPos - 30 * s, 40 * s, 30 * s);

                // Eyes
                ctx.fillStyle = this.eyeBlink > 0 ? '#333' : '#FFF';
                ctx.fillRect(this.x * s + 12 * s, yPos - 20 * s, 8 * s, this.eyeBlink > 0 ? 2 * s : 8 * s);
                ctx.fillRect(this.x * s + 30 * s, yPos - 20 * s, 8 * s, this.eyeBlink > 0 ? 2 * s : 8 * s);
                
                // Draw "T" on the body
                ctx.fillStyle = '#FFF';
                ctx.font = `bold ${25 * s}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('T', this.x * s + this.width * s / 2, yPos + this.height * s / 2);
            }
        }

        // Obstacle class
        class Obstacle {
            constructor(x) {
                this.x = x;
                this.y = 0;
                this.width = 40;
                this.height = 40;
                this.color = '#8B4513';
                this.type = Math.random() > 0.5 ? 'gear' : 'oil';
            }

            update(deltaTime) {
                this.x -= gameSpeed * deltaTime / 1000;
                this.y = canvas.height - 100 * scale - this.height * scale;
            }

            draw() {
                const s = scale;
                
                if (this.type === 'gear') {
                    // Draw gear
                    ctx.fillStyle = '#696969';
                    ctx.beginPath();
                    ctx.arc(this.x + 20 * s, this.y + 20 * s, 20 * s, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Gear teeth
                    ctx.fillStyle = '#505050';
                    for (let i = 0; i < 8; i++) {
                        const angle = (i / 8) * Math.PI * 2;
                        ctx.fillRect(
                            this.x + 20 * s + Math.cos(angle) * 15 * s - 5 * s,
                            this.y + 20 * s + Math.sin(angle) * 15 * s - 5 * s,
                            10 * s, 10 * s
                        );
                    }
                } else {
                    // Draw oil spill
                    ctx.fillStyle = '#2F4F4F';
                    ctx.beginPath();
                    ctx.ellipse(this.x + 20 * s, this.y + 30 * s, 25 * s, 10 * s, 0, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        // Game objects
        const robot = new Robot();
        const obstacles = [];
        let obstacleTimer = 0;
        
        // Cloud objects for parallax effect
        const clouds = [];
        for (let i = 0; i < 3; i++) {
            clouds.push({
                x: Math.random() * 800,
                y: 50 + Math.random() * 100,
                width: 60 + Math.random() * 40,
                speed: 20 + Math.random() * 30
            });
        }

        // Draw clouds for parallax effect
        function drawClouds() {
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            
            clouds.forEach(cloud => {
                const s = scale;
                // Draw cloud as overlapping circles
                ctx.beginPath();
                ctx.arc(cloud.x * s, cloud.y * s, cloud.width * s * 0.4, 0, Math.PI * 2);
                ctx.arc(cloud.x * s + cloud.width * s * 0.3, cloud.y * s, cloud.width * s * 0.5, 0, Math.PI * 2);
                ctx.arc(cloud.x * s + cloud.width * s * 0.6, cloud.y * s, cloud.width * s * 0.4, 0, Math.PI * 2);
                ctx.fill();
            });
        }
        
        // Update clouds position
        function updateClouds(deltaTime) {
            clouds.forEach(cloud => {
                cloud.x -= cloud.speed * deltaTime / 1000;
                
                // Wrap around when cloud goes off screen
                if (cloud.x < -100) {
                    cloud.x = 800 + Math.random() * 200;
                    cloud.y = 50 + Math.random() * 100;
                    cloud.width = 60 + Math.random() * 40;
                }
            });
        }

        // Ground
        function drawGround() {
            const groundY = canvas.height - 100 * scale;
            
            ctx.fillStyle = '#228B22';
            ctx.fillRect(0, groundY, canvas.width, canvas.height - groundY);
            
            // Grass details
            ctx.fillStyle = '#32CD32';
            for (let i = 0; i < canvas.width; i += 20 * scale) {
                ctx.fillRect(i, groundY, 10 * scale, 5 * scale);
            }
        }

        // Game loop
        function gameLoop(currentTime) {
            if (!gameRunning) {
                cancelAnimationFrame(animationId);
                return;
            }

            // Calculate delta time
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;

            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Sky background
            ctx.fillStyle = '#87CEEB';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Update and draw clouds
            updateClouds(deltaTime);
            drawClouds();

            // Draw ground
            drawGround();

            // Update and draw robot
            robot.update();
            robot.draw();

            // Spawn obstacles
            obstacleTimer += deltaTime;
            if (obstacleTimer > 2000 + Math.random() * 1500) { // spawn every 2-3.5 seconds (easier for kids)
                // Spawn at a fixed distance (800 pixels) scaled to current screen size
                obstacles.push(new Obstacle(800 * scale));
                obstacleTimer = 0;
            }

            // Update and draw obstacles
            for (let i = obstacles.length - 1; i >= 0; i--) {
                const obstacle = obstacles[i];
                obstacle.update(deltaTime);
                obstacle.draw();

                // Remove off-screen obstacles
                if (obstacle.x < -50) {
                    obstacles.splice(i, 1);
                    score++;
                    scoreEl.textContent = score;
                    
                    // Increase speed every 5 points
                    if (score % 5 === 0) {
                        gameSpeed += 24; // increase by 24 pixels per second (20% less)
                    }
                }

                // Collision detection
                const s = scale;
                if (robot.x * s < obstacle.x + obstacle.width * s &&
                    robot.x * s + robot.width * s > obstacle.x &&
                    robot.y < obstacle.y + obstacle.height * s &&
                    robot.y + robot.height * s > obstacle.y) {
                    gameOver();
                    return;
                }
            }

            animationId = requestAnimationFrame(gameLoop);
        }

        // Game over
        function gameOver() {
            gameRunning = false;
            cancelAnimationFrame(animationId);
            
            setTimeout(() => {
                canRestart = true;
            }, 500);
            
            messageEl.style.cssText = 'display: flex !important';
            messageEl.className = 'modal-overlay';
            messageEl.innerHTML = `
                <div class="modal-content">
                    <h1 class="modal-title">Game Over!</h1>
                    <div style="text-align: center;">
                        <div style="font-size: clamp(60px, 10vw, 120px); margin: 10px 0;">ü§ñ</div>
                        <div style="color: #333; font-size: clamp(20px, 3vw, 28px); margin: 10px 0;">
                            Great job! You scored <strong style="color: #4169E1;">${score}</strong> points!
                        </div>
                        <div style="color: #666; font-size: clamp(16px, 2.5vw, 20px); margin-top: 20px;">
                            Tap anywhere to play again
                        </div>
                    </div>
                </div>
            `;
        }

        // Restart game
        function restartGame() {
            score = 0;
            scoreEl.textContent = score;
            gameSpeed = 240; // Reset to initial slower speed
            obstacles.length = 0;
            obstacleTimer = 0;
            robot.y = canvas.height - 120 * scale - robot.height * scale;
            robot.velocityY = 0;
            robot.grounded = true;
            messageEl.innerHTML = '';
            messageEl.style.cssText = '';
            messageEl.className = '';
            canRestart = false;
            gameRunning = true;
            tapToJumpEl.style.display = 'block';
            lastTime = performance.now();
            gameLoop(lastTime);
        }

        // Controls
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                if (gameRunning) {
                    robot.jump();
                } else if (canRestart) {
                    restartGame();
                }
            }
        });

        // Touch controls - use touchstart for immediate response
        document.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (gameRunning) {
                robot.jump();
                tapToJumpEl.style.display = 'none';
            } else if (canRestart) {
                restartGame();
            }
        });
        
        // Mouse controls as fallback
        document.addEventListener('mousedown', (e) => {
            e.preventDefault();
            if (gameRunning) {
                robot.jump();
                tapToJumpEl.style.display = 'none';
            } else if (canRestart) {
                restartGame();
            }
        });

        // Start button handler
        function startGame() {
            startScreenEl.style.display = 'none';
            gameStarted = true;
            gameRunning = true;
            score = 0;
            scoreEl.textContent = score;
            obstacles.length = 0;
            obstacleTimer = 0;
            robot.y = robot.groundY - robot.height * scale;
            robot.velocityY = 0;
            robot.grounded = true;
            lastTime = performance.now();
            gameLoop(lastTime);
            
            // Show tap to jump hint for a few seconds
            tapToJumpEl.style.display = 'block';
            setTimeout(() => {
                if (gameRunning) {
                    tapToJumpEl.style.display = 'none';
                }
            }, 3000);
        }
        
        // Start button click handler
        startButtonEl.addEventListener('click', startGame);
    </script>
</body>
</html>