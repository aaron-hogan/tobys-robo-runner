<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Toby's Robo-Runner</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div id="gameContainer">
        <div id="gameInfo">
            <div>Score: <span id="score">0</span></div>
        </div>
        <canvas id="gameCanvas"></canvas>
        <div id="tapToJump">Tap to Jump! ü§ñ</div>
        <div id="message"></div>
        <div id="startScreen" class="modal-overlay">
            <div class="modal-content">
                <h1 class="modal-title">Toby's Robo-Runner ü§ñ</h1>
                <div class="instructions-container">
                    <div class="instruction-item">
                        <span style="font-size: 1.5em;">ü§ñ</span>
                        <span>You are a robot!</span>
                    </div>
                    <div class="instruction-item">
                        <span style="font-size: 1.5em;">üëÜ</span>
                        <span>Tap to jump</span>
                    </div>
                    <div class="instruction-item">
                        <span style="font-size: 1.5em;">‚öôÔ∏è</span>
                        <span>Jump over obstacles</span>
                    </div>
                    <div class="instruction-item">
                        <span style="font-size: 1.5em;">üèÉ</span>
                        <span>Get points!</span>
                    </div>
                </div>
                <button id="startButton" class="modal-button">
                    Start Game! üéÆ
                </button>
            </div>
        </div>
        <div id="characterSelect" class="modal-overlay" style="display: none;">
            <div class="modal-content">
                <h1 class="modal-title">Choose Your Robot!</h1>
                <div class="character-grid">
                    <div class="character-option" data-character="blue">
                        <canvas id="bluePreview" width="100" height="120"></canvas>
                        <h3>Toby</h3>
                        <p>The original blue robot</p>
                    </div>
                    <div class="character-option" data-character="green">
                        <canvas id="greenPreview" width="100" height="120"></canvas>
                        <h3>Eco</h3>
                        <p>The green nature robot</p>
                    </div>
                    <div class="character-option" data-character="red">
                        <canvas id="redPreview" width="100" height="120"></canvas>
                        <h3>Blaze</h3>
                        <p>The red speed robot</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');
        const messageEl = document.getElementById('message');
        const tapToJumpEl = document.getElementById('tapToJump');
        const startScreenEl = document.getElementById('startScreen');
        const startButtonEl = document.getElementById('startButton');
        
        // Set canvas size to full screen
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            // Scale everything based on canvas size
            return Math.min(canvas.width / 800, canvas.height / 400);
        }
        
        let scale = resizeCanvas();
        window.addEventListener('resize', () => {
            scale = resizeCanvas();
        });

        // Game variables
        let score = 0;
        let gameSpeed = 240; // pixels per second (reduced by 20% for easier gameplay)
        let gameRunning = false;
        let gameStarted = false;
        let canRestart = false;
        let animationId = null;
        let lastTime = 0;
        let selectedCharacter = 'blue'; // Default character
        
        // Character definitions
        const characters = {
            blue: {
                name: 'Toby',
                bodyColor: '#4169E1',
                headColor: '#6495ED',
                letter: 'T'
            },
            green: {
                name: 'Eco',
                bodyColor: '#228B22',
                headColor: '#32CD32',
                letter: 'E'
            },
            red: {
                name: 'Blaze',
                bodyColor: '#DC143C',
                headColor: '#FF6347',
                letter: 'B'
            }
        };

        // Robot class
        class Robot {
            constructor(characterType = 'blue') {
                this.x = 100;
                this.y = 0;
                this.width = 50;
                this.height = 60;
                this.velocityY = 0;
                this.gravity = 0.8;
                this.jumpPower = -18;
                this.grounded = true;
                this.character = characters[characterType];
                this.eyeBlink = 0;
                this.groundY = 0;
                this.legAnimation = 0;
            }

            jump() {
                if (this.grounded) {
                    this.velocityY = this.jumpPower * scale;
                    this.grounded = false;
                }
            }

            update() {
                // Apply gravity
                this.velocityY += this.gravity * scale;
                this.y += this.velocityY;

                // Ground collision
                this.groundY = canvas.height - 120 * scale;
                if (this.y > this.groundY - this.height * scale) {
                    this.y = this.groundY - this.height * scale;
                    this.velocityY = 0;
                    this.grounded = true;
                }

                // Blink animation
                this.eyeBlink = Math.random() > 0.98 ? 10 : Math.max(0, this.eyeBlink - 1);
                
                // Leg animation for running
                if (this.grounded && gameRunning) {
                    this.legAnimation += 0.3;
                }
            }

            draw() {
                const s = scale;
                
                // Add bounce effect when running
                let bounceOffset = 0;
                if (this.grounded && gameRunning) {
                    bounceOffset = Math.sin(this.legAnimation) * 3; // Smooth up/down motion synced with legs
                }
                const yPos = this.y - bounceOffset * s;
                
                // Draw unique features based on character
                if (this.character.name === 'Eco') {
                    // Draw antenna for green robot
                    ctx.fillStyle = '#333';
                    ctx.fillRect(this.x * s + 23 * s, yPos - 40 * s, 4 * s, 10 * s);
                    ctx.fillStyle = '#FFFF00';
                    ctx.beginPath();
                    ctx.arc(this.x * s + 25 * s, yPos - 42 * s, 6 * s, 0, Math.PI * 2);
                    ctx.fill();
                } else if (this.character.name === 'Blaze') {
                    // Draw spikes for red robot
                    ctx.fillStyle = '#8B0000';
                    // Back spikes
                    for (let i = 0; i < 3; i++) {
                        ctx.beginPath();
                        ctx.moveTo(this.x * s + this.width * s, yPos + 10 * s + i * 20 * s);
                        ctx.lineTo(this.x * s + this.width * s + 10 * s, yPos + 20 * s + i * 20 * s);
                        ctx.lineTo(this.x * s + this.width * s, yPos + 30 * s + i * 20 * s);
                        ctx.fill();
                    }
                }
                
                // Animated legs (draw from body position to ensure no gap)
                ctx.fillStyle = this.character.headColor;
                const legOffset1 = Math.sin(this.legAnimation) * 5;
                const legOffset2 = Math.sin(this.legAnimation + Math.PI) * 5;
                
                if (this.grounded && gameRunning) {
                    // Running animation - legs start from body bottom
                    ctx.fillRect(this.x * s + 10 * s + legOffset1 * s, yPos + this.height * s, 10 * s, 20 * s + bounceOffset * s);
                    ctx.fillRect(this.x * s + 30 * s + legOffset2 * s, yPos + this.height * s, 10 * s, 20 * s + bounceOffset * s);
                } else {
                    // Static legs when jumping or game over
                    ctx.fillRect(this.x * s + 10 * s, this.y + this.height * s, 10 * s, 20 * s);
                    ctx.fillRect(this.x * s + 30 * s, this.y + this.height * s, 10 * s, 20 * s);
                }
                
                // Right arm (behind body)
                ctx.fillStyle = this.character.headColor;
                const armOffset = Math.sin(this.legAnimation + Math.PI) * 5; // Offset from legs for natural motion
                
                if (this.grounded && gameRunning) {
                    // Right arm (behind) - vertical orientation, horizontal movement
                    ctx.fillRect(this.x * s + this.width * s - 5 * s - armOffset * s, yPos + 10 * s, 10 * s, 30 * s);
                } else {
                    // Static right arm
                    ctx.fillRect(this.x * s + this.width * s - 5 * s, yPos + 10 * s, 10 * s, 30 * s);
                }
                
                // Body
                ctx.fillStyle = this.character.bodyColor;
                ctx.fillRect(this.x * s, yPos, this.width * s, this.height * s);
                
                // Left arm (in front of body)
                ctx.fillStyle = this.character.headColor;
                if (this.grounded && gameRunning) {
                    // Left arm (front) - vertical orientation, horizontal movement
                    ctx.fillRect(this.x * s - 5 * s + armOffset * s, yPos + 10 * s, 10 * s, 30 * s);
                } else {
                    // Static left arm
                    ctx.fillRect(this.x * s - 5 * s, yPos + 10 * s, 10 * s, 30 * s);
                }

                // Head
                ctx.fillStyle = this.character.headColor;
                ctx.fillRect(this.x * s + 5 * s, yPos - 30 * s, 40 * s, 30 * s);

                // Eyes
                ctx.fillStyle = this.eyeBlink > 0 ? '#333' : '#FFF';
                ctx.fillRect(this.x * s + 12 * s, yPos - 20 * s, 8 * s, this.eyeBlink > 0 ? 2 * s : 8 * s);
                ctx.fillRect(this.x * s + 30 * s, yPos - 20 * s, 8 * s, this.eyeBlink > 0 ? 2 * s : 8 * s);
                
                // Draw letter on the body
                ctx.fillStyle = '#FFF';
                ctx.font = `bold ${25 * s}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.character.letter, this.x * s + this.width * s / 2, yPos + this.height * s / 2);
            }
        }

        // Obstacle class
        class Obstacle {
            constructor(x) {
                this.x = x;
                this.y = 0;
                this.width = 40;
                this.height = 40;
                this.color = '#8B4513';
                this.type = Math.random() > 0.5 ? 'gear' : 'oil';
            }

            update(deltaTime) {
                this.x -= gameSpeed * deltaTime / 1000;
                this.y = canvas.height - 100 * scale - this.height * scale;
            }

            draw() {
                const s = scale;
                
                if (this.type === 'gear') {
                    // Draw gear
                    ctx.fillStyle = '#696969';
                    ctx.beginPath();
                    ctx.arc(this.x + 20 * s, this.y + 20 * s, 20 * s, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Gear teeth
                    ctx.fillStyle = '#505050';
                    for (let i = 0; i < 8; i++) {
                        const angle = (i / 8) * Math.PI * 2;
                        ctx.fillRect(
                            this.x + 20 * s + Math.cos(angle) * 15 * s - 5 * s,
                            this.y + 20 * s + Math.sin(angle) * 15 * s - 5 * s,
                            10 * s, 10 * s
                        );
                    }
                } else {
                    // Draw oil spill
                    ctx.fillStyle = '#2F4F4F';
                    ctx.beginPath();
                    ctx.ellipse(this.x + 20 * s, this.y + 30 * s, 25 * s, 10 * s, 0, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        // Game objects
        let robot = new Robot(selectedCharacter);
        const obstacles = [];
        let obstacleTimer = 0;
        
        // Cloud objects for parallax effect
        const clouds = [];
        for (let i = 0; i < 3; i++) {
            clouds.push({
                x: Math.random() * 800,
                y: 50 + Math.random() * 100,
                width: 60 + Math.random() * 40,
                speed: 20 + Math.random() * 30
            });
        }

        // Draw clouds for parallax effect
        function drawClouds() {
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            
            clouds.forEach(cloud => {
                const s = scale;
                // Draw cloud as overlapping circles
                ctx.beginPath();
                ctx.arc(cloud.x * s, cloud.y * s, cloud.width * s * 0.4, 0, Math.PI * 2);
                ctx.arc(cloud.x * s + cloud.width * s * 0.3, cloud.y * s, cloud.width * s * 0.5, 0, Math.PI * 2);
                ctx.arc(cloud.x * s + cloud.width * s * 0.6, cloud.y * s, cloud.width * s * 0.4, 0, Math.PI * 2);
                ctx.fill();
            });
        }
        
        // Update clouds position
        function updateClouds(deltaTime) {
            clouds.forEach(cloud => {
                cloud.x -= cloud.speed * deltaTime / 1000;
                
                // Wrap around when cloud goes off screen
                if (cloud.x < -100) {
                    cloud.x = 800 + Math.random() * 200;
                    cloud.y = 50 + Math.random() * 100;
                    cloud.width = 60 + Math.random() * 40;
                }
            });
        }

        // Ground
        function drawGround() {
            const groundY = canvas.height - 100 * scale;
            
            ctx.fillStyle = '#228B22';
            ctx.fillRect(0, groundY, canvas.width, canvas.height - groundY);
            
            // Grass details
            ctx.fillStyle = '#32CD32';
            for (let i = 0; i < canvas.width; i += 20 * scale) {
                ctx.fillRect(i, groundY, 10 * scale, 5 * scale);
            }
        }

        // Game loop
        function gameLoop(currentTime) {
            if (!gameRunning) {
                cancelAnimationFrame(animationId);
                return;
            }

            // Calculate delta time
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;

            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Sky background
            ctx.fillStyle = '#87CEEB';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Update and draw clouds
            updateClouds(deltaTime);
            drawClouds();

            // Draw ground
            drawGround();

            // Update and draw robot
            robot.update();
            robot.draw();

            // Spawn obstacles
            obstacleTimer += deltaTime;
            if (obstacleTimer > 2000 + Math.random() * 1500) { // spawn every 2-3.5 seconds (easier for kids)
                // Spawn at a fixed distance (800 pixels) scaled to current screen size
                obstacles.push(new Obstacle(800 * scale));
                obstacleTimer = 0;
            }

            // Update and draw obstacles
            for (let i = obstacles.length - 1; i >= 0; i--) {
                const obstacle = obstacles[i];
                obstacle.update(deltaTime);
                obstacle.draw();

                // Remove off-screen obstacles
                if (obstacle.x < -50) {
                    obstacles.splice(i, 1);
                    score++;
                    scoreEl.textContent = score;
                    
                    // Increase speed every 5 points
                    if (score % 5 === 0) {
                        gameSpeed += 24; // increase by 24 pixels per second (20% less)
                    }
                }

                // Collision detection
                const s = scale;
                if (robot.x * s < obstacle.x + obstacle.width * s &&
                    robot.x * s + robot.width * s > obstacle.x &&
                    robot.y < obstacle.y + obstacle.height * s &&
                    robot.y + robot.height * s > obstacle.y) {
                    gameOver();
                    return;
                }
            }

            animationId = requestAnimationFrame(gameLoop);
        }

        // Game over
        function gameOver() {
            gameRunning = false;
            cancelAnimationFrame(animationId);
            
            setTimeout(() => {
                canRestart = true;
            }, 500);
            
            messageEl.style.cssText = 'display: flex !important';
            messageEl.className = 'modal-overlay';
            messageEl.innerHTML = `
                <div class="modal-content">
                    <h1 class="modal-title">Game Over!</h1>
                    <div style="text-align: center;">
                        <div style="font-size: clamp(60px, 10vw, 120px); margin: 10px 0;">ü§ñ</div>
                        <div style="color: #333; font-size: clamp(20px, 3vw, 28px); margin: 10px 0;">
                            Great job! You scored <strong style="color: #4169E1;">${score}</strong> points!
                        </div>
                        <div style="display: flex; gap: 20px; justify-content: center; margin-top: 30px; flex-wrap: wrap;">
                            <button class="modal-button" onclick="restartGame()">Play Again!</button>
                            <button class="modal-button" style="background: #666;" onclick="showCharacterSelect()">Change Robot</button>
                        </div>
                    </div>
                </div>
            `;
        }

        // Show character selection from game over
        function showCharacterSelect() {
            messageEl.style.cssText = '';
            messageEl.className = '';
            messageEl.innerHTML = '';
            characterSelectEl.style.display = 'flex';
            canRestart = false;
        }
        
        // Restart game
        function restartGame() {
            score = 0;
            scoreEl.textContent = score;
            gameSpeed = 240; // Reset to initial slower speed
            obstacles.length = 0;
            obstacleTimer = 0;
            robot.y = canvas.height - 120 * scale - robot.height * scale;
            robot.velocityY = 0;
            robot.grounded = true;
            messageEl.innerHTML = '';
            messageEl.style.cssText = '';
            messageEl.className = '';
            canRestart = false;
            gameRunning = true;
            tapToJumpEl.style.display = 'block';
            lastTime = performance.now();
            gameLoop(lastTime);
        }

        // Controls
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                if (gameRunning) {
                    robot.jump();
                } else if (canRestart) {
                    restartGame();
                }
            }
        });

        // Touch controls - use touchstart for immediate response
        document.addEventListener('touchstart', (e) => {
            if (gameRunning) {
                e.preventDefault();
                robot.jump();
                tapToJumpEl.style.display = 'none';
            }
        });
        
        // Mouse controls as fallback
        document.addEventListener('mousedown', (e) => {
            if (gameRunning) {
                e.preventDefault();
                robot.jump();
                tapToJumpEl.style.display = 'none';
            }
        });

        // Start button handler
        function startGame() {
            startScreenEl.style.display = 'none';
            gameStarted = true;
            gameRunning = true;
            score = 0;
            scoreEl.textContent = score;
            obstacles.length = 0;
            obstacleTimer = 0;
            robot.y = robot.groundY - robot.height * scale;
            robot.velocityY = 0;
            robot.grounded = true;
            lastTime = performance.now();
            gameLoop(lastTime);
            
            // Show tap to jump hint for a few seconds
            tapToJumpEl.style.display = 'block';
            setTimeout(() => {
                if (gameRunning) {
                    tapToJumpEl.style.display = 'none';
                }
            }, 3000);
        }
        
        // Character selection
        const characterSelectEl = document.getElementById('characterSelect');
        const characterOptions = document.querySelectorAll('.character-option');
        
        // Draw robot preview - matching exact game appearance
        function drawRobotPreview(canvasId, characterType) {
            const previewCanvas = document.getElementById(canvasId);
            const previewCtx = previewCanvas.getContext('2d');
            const char = characters[characterType];
            const s = 0.8; // Smaller scale for preview
            const x = 25; // Starting x position
            const y = 40; // Starting y position
            
            previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
            
            // Draw unique features for Eco and Blaze
            if (char.name === 'Eco') {
                // Antenna
                previewCtx.fillStyle = '#333';
                previewCtx.fillRect(x + 23 * s, y - 40 * s, 4 * s, 10 * s);
                previewCtx.fillStyle = '#FFFF00';
                previewCtx.beginPath();
                previewCtx.arc(x + 25 * s, y - 42 * s, 6 * s, 0, Math.PI * 2);
                previewCtx.fill();
            } else if (char.name === 'Blaze') {
                // Spikes
                previewCtx.fillStyle = '#8B0000';
                for (let i = 0; i < 3; i++) {
                    previewCtx.beginPath();
                    previewCtx.moveTo(x + 50 * s, y + 10 * s + i * 20 * s);
                    previewCtx.lineTo(x + 50 * s + 10 * s, y + 20 * s + i * 20 * s);
                    previewCtx.lineTo(x + 50 * s, y + 30 * s + i * 20 * s);
                    previewCtx.fill();
                }
            }
            
            // Legs
            previewCtx.fillStyle = char.headColor;
            previewCtx.fillRect(x + 10 * s, y + 60 * s, 10 * s, 20 * s);
            previewCtx.fillRect(x + 30 * s, y + 60 * s, 10 * s, 20 * s);
            
            // Right arm (behind body)
            previewCtx.fillRect(x + 45 * s, y + 10 * s, 10 * s, 30 * s);
            
            // Body
            previewCtx.fillStyle = char.bodyColor;
            previewCtx.fillRect(x, y, 50 * s, 60 * s);
            
            // Left arm (in front)
            previewCtx.fillStyle = char.headColor;
            previewCtx.fillRect(x - 5 * s, y + 10 * s, 10 * s, 30 * s);
            
            // Head
            previewCtx.fillStyle = char.headColor;
            previewCtx.fillRect(x + 5 * s, y - 30 * s, 40 * s, 30 * s);
            
            // Eyes (facing right)
            previewCtx.fillStyle = '#FFF';
            previewCtx.fillRect(x + 12 * s, y - 20 * s, 8 * s, 8 * s);
            previewCtx.fillRect(x + 30 * s, y - 20 * s, 8 * s, 8 * s);
            
            // Letter on body
            previewCtx.fillStyle = '#FFF';
            previewCtx.font = `bold ${25 * s}px Arial`;
            previewCtx.textAlign = 'center';
            previewCtx.textBaseline = 'middle';
            previewCtx.fillText(char.letter, x + 25 * s, y + 30 * s);
        }
        
        // Initialize previews
        drawRobotPreview('bluePreview', 'blue');
        drawRobotPreview('greenPreview', 'green');
        drawRobotPreview('redPreview', 'red');
        
        // Character selection handlers
        characterOptions.forEach(option => {
            option.addEventListener('click', () => {
                characterOptions.forEach(opt => opt.classList.remove('selected'));
                option.classList.add('selected');
                selectedCharacter = option.dataset.character;
                
                // Create new robot with selected character
                robot = new Robot(selectedCharacter);
                
                // Hide character select and start game
                characterSelectEl.style.display = 'none';
                startGame();
            });
        });
        
        // Start button click handler - show character selection
        startButtonEl.addEventListener('click', () => {
            startScreenEl.style.display = 'none';
            characterSelectEl.style.display = 'flex';
            
            // Pre-select the current character
            characterOptions.forEach(opt => {
                opt.classList.remove('selected');
                if (opt.dataset.character === selectedCharacter) {
                    opt.classList.add('selected');
                }
            });
        });
    </script>
</body>
</html>